//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB)
// Reference Implementation, v2.1.3-b01-fcs
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source
// schema.
// Generated on: 2009.10.26 at 12:24:15 PM CET
//

package fr.ign.cogit.gru3d.regleUrba.reglesUrbanismes.regles;

import java.awt.Color;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;

import javax.media.j3d.Appearance;
import javax.media.j3d.Billboard;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Font3D;
import javax.media.j3d.FontExtrusion;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.PointArray;
import javax.media.j3d.Shape3D;
import javax.media.j3d.Text3D;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3f;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlType;

import fr.ign.cogit.geoxygene.api.spatial.coordgeom.IDirectPosition;
import fr.ign.cogit.geoxygene.api.spatial.coordgeom.IPolygon;
import fr.ign.cogit.geoxygene.sig3d.convert.java3d.ConversionJava3DGeOxygene;
import fr.ign.cogit.geoxygene.sig3d.convert.transform.Extrusion2DObject;
import fr.ign.cogit.geoxygene.sig3d.geometry.Box3D;
import fr.ign.cogit.geoxygene.sig3d.representation.sample.ObjectCartoon;
import fr.ign.cogit.geoxygene.sig3d.sample.Symbology;
import fr.ign.cogit.geoxygene.spatial.coordgeom.DirectPosition;
import fr.ign.cogit.geoxygene.spatial.coordgeom.DirectPositionList;
import fr.ign.cogit.geoxygene.spatial.coordgeom.GM_LineString;
import fr.ign.cogit.geoxygene.spatial.coordgeom.GM_Polygon;
import fr.ign.cogit.geoxygene.spatial.geomprim.GM_Point;
import fr.ign.cogit.geoxygene.spatial.geomprim.GM_Solid;
import fr.ign.cogit.gru3d.regleUrba.Executor;
import fr.ign.cogit.gru3d.regleUrba.reglesUrbanismes.Constant;
import fr.ign.cogit.gru3d.regleUrba.representation.ContrainteCOSRepresentation;
import fr.ign.cogit.gru3d.regleUrba.representation.Incoherence;
import fr.ign.cogit.gru3d.regleUrba.schemageo.Batiment;
import fr.ign.cogit.gru3d.regleUrba.schemageo.Parcelle;
import fr.ign.cogit.gru3d.regleUrba.util.Prospect;

/**
 * <p>
 * Java class for LimitationCOS complex type.
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 * 
 * <pre>
 * &lt;complexType name="LimitationCOS">
 *   &lt;complexContent>
 *     &lt;extension base="{}Consequence">
 *       &lt;sequence>
 *         &lt;element name="cosMin" type="{http://www.w3.org/2001/XMLSchema}double"/>
 *         &lt;element name="cosMax" type="{http://www.w3.org/2001/XMLSchema}double"/>
 *       &lt;/sequence>
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "LimitationCOS", propOrder = { "cosMin", "cosMax" })
public class LimitationCOS extends Consequence {

  public LimitationCOS() {
    super();
  }

  public LimitationCOS(double cosMin, double cosMax) {
    super();
    this.cosMin = cosMin;
    this.cosMax = cosMax;
  }

  protected double cosMin;
  protected double cosMax;

  /**
   * Gets the value of the cosMin property.
   */
  public double getCosMin() {
    return this.cosMin;
  }

  /**
   * Sets the value of the cosMin property.
   */
  public void setCosMin(double value) {
    this.cosMin = value;
  }

  /**
   * Gets the value of the cosMax property.
   */
  public double getCosMax() {
    return this.cosMax;
  }

  /**
   * Sets the value of the cosMax property.
   */
  public void setCosMax(double value) {
    this.cosMax = value;
  }

  @Override
  public String toString() {
    return "Le COS doit être compris sur la parcelle entre : " + this.cosMin
        + " et " + this.cosMax;
  }

  // On prend l'aire au sol des toits
  // venant de données Bati3D c'est ok
  // il faudrait faire une découpe pour de vraies données 3D
  // On considère qu'un étage fait 2.7m
  // On compte le nombre d'étage en prenant la hauteur du corps
  // et on multiplie l'aire par ce nombre
  @Override
  public List<Incoherence> isConsequenceChecked(Parcelle p, boolean represent) {

    List<Incoherence> lIncoherence = new ArrayList<Incoherence>();

    double COSactuel = p.assessFAR(Constant.COEFF_COS);

    COSactuel = ((int) (COSactuel * 100)) / 100.0;
    
    
    System.out.println("COS : " +COSactuel);

    if (COSactuel > this.cosMax) {
      if (Executor.VERBOSE) {
        // System.out
        // .println("Conséquence non vérifiée : COS Max dépassé");

      }
      
      
      if(represent){

      GM_Point pt = new GM_Point(p.getGeom().centroid());
      pt.getPosition().setZ(p.getGeom().coord().get(0).getZ());

      BranchGroup bg = ContrainteCOSRepresentation.generateBG(pt, 50.0,
          Color.red, 10.0, this.cosMin + "", COSactuel + "", this.cosMax + "",
          2, 2, Symbology.class.getResource("/demo3D/reglesurba/cos.png")
              .getPath());
      lIncoherence.add(new Incoherence(this, p, bg));
      }else{
        lIncoherence.add(new Incoherence(this));
        return lIncoherence;
      }
    }

    if (COSactuel < this.cosMin) {
      if (Executor.VERBOSE) {
        // System.out
        // .println("Conséquence non vérifiée : COS Min non respecté");

      }

      // lIncoherence.add(new Incoherence(this, p, this.getBranchGroup1(p,
      // false,
      // COSactuel)));

      
      
      if(represent){

        GM_Point pt = new GM_Point(p.getGeom().centroid());
        pt.getPosition().setZ(p.getGeom().coord().get(0).getZ());
      BranchGroup bg = ContrainteCOSRepresentation.generateBG(pt, 50.0,
          Color.red, 10.0, this.cosMin + "", COSactuel + "", this.cosMax + "",
          2, 0.2, Symbology.class.getResource("/demo3D/reglesurba/cos.png")
              .getPath());
      lIncoherence.add(new Incoherence(this, p, bg));
      }else{
        lIncoherence.add(new Incoherence(this));
        return lIncoherence;
      }

    }

    if (Executor.VERBOSE) {
      if (lIncoherence.size() == 0) {
        System.out.println("Conséquence vérifiée : COS");
      }
    }

    return lIncoherence;

  }

  private BranchGroup getBranchGroupEmpParcelle(Parcelle p, boolean max) {

    GM_Polygon poly = (GM_Polygon) p.getGeom();

    double CES = poly.area() / (p.getGeom().area());

    double nbEtage = 0;
    if (max) {
      nbEtage = this.getCosMax() / (CES);
    } else {
      nbEtage = this.getCosMin() / (CES);

    }

    GM_Solid sol = (GM_Solid) Extrusion2DObject.convertFromPolygon(poly, p
        .getGeom().coord().get(0).getZ(), p.getGeom().coord().get(0).getZ()
        + nbEtage * 3);

    Appearance ap;

    if (max) {
      ap = Prospect.genereApparence(true, Color.red, 1, true);
    } else {
      ap = Prospect.genereApparence(true, Color.green, 1, true);
    }

    BranchGroup bg = new BranchGroup();
    bg.addChild(new Shape3D(ConversionJava3DGeOxygene
        .fromOrientableSToTriangleArray(sol.getFacesList()).getGeometryArray(),
        ap));

    return bg;

  }

  private BranchGroup getBranchGroup1(Parcelle p, boolean max, double COSActu) {

    COSActu = ((double) Math.round(100 * COSActu)) / 100;

    BranchGroup bg = new BranchGroup();
    // On parcourt la liste des batiments
    List<Batiment> lBatiments = p.getlBatimentsContenus();

    int nbBatiments = lBatiments.size();

    double hauteuMax = 0;

    for (int i = 0; i < nbBatiments; i++) {
      Batiment bati = lBatiments.get(i);

      Box3D b = new Box3D(bati.getGeom());

      double hauteur = b.getURDP().getZ() - b.getLLDP().getZ();

      hauteuMax = Math.max(hauteur, hauteuMax);
    }

    IDirectPosition dp = p.getGeom().centroid();

    PointArray pA = new PointArray(1, GeometryArray.COORDINATES
        | GeometryArray.COLOR_3);

    pA.setCapability(GeometryArray.ALLOW_COLOR_READ);
    pA.setCapability(GeometryArray.ALLOW_COLOR_WRITE);

    // Rotation en X, en Y et en Z
    Transform3D rotX = new Transform3D();
    rotX.rotX(0);// -Math.PI / 2.0);
    TransformGroup tgRotX = new TransformGroup(rotX);
    tgRotX.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);

    Transform3D rotY = new Transform3D();
    rotY.rotY(0);
    TransformGroup tgRotY = new TransformGroup(rotY);
    tgRotY.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);

    Transform3D rotZ = new Transform3D();
    rotZ.rotZ(0);
    TransformGroup tgRotZ = new TransformGroup(rotZ);
    tgRotZ.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);

    Font3D f3d = new Font3D(new Font("Arial", Font.PLAIN, 1),
        new FontExtrusion());
    Text3D text3D = null;

    if (max) {
      text3D = new Text3D(f3d, COSActu + ">" + this.getCosMax(), new Point3f(0,
          0, 0),

      Text3D.ALIGN_CENTER, Text3D.PATH_RIGHT);

    } else {

      text3D = new Text3D(f3d, COSActu + "<" + this.getCosMin(), new Point3f(0,
          0, 0),

      Text3D.ALIGN_CENTER, Text3D.PATH_RIGHT);
    }

    text3D.setCapability(Text3D.ALLOW_FONT3D_WRITE);
    text3D.setCapability(Geometry.ALLOW_INTERSECT);

    Shape3D s3D1 = new Shape3D();
    s3D1.setGeometry(text3D);

    if (max) {
      s3D1.setAppearance(Prospect.genereApparence(true, Color.red, 1, true));

    } else {
      s3D1.setAppearance(Prospect.genereApparence(true, Color.green, 1, true));
    }

    s3D1.setCapability(Shape3D.ALLOW_APPEARANCE_WRITE);
    s3D1.setCapability(Shape3D.ALLOW_APPEARANCE_READ);

    // On place le centre de la sphère aux bonnes coordonnées
    Transform3D translate = new Transform3D();
    translate.set(new Vector3f((float) dp.getX(), (float) dp.getY(),
        (float) (hauteuMax + p.getGeom().coord().get(0).getZ() + 2)));

    TransformGroup objScale = new TransformGroup();
    Transform3D t3d = new Transform3D();
    t3d.setScale(3);
    objScale.setTransform(t3d);
    objScale.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);

    TransformGroup tg1 = new TransformGroup(translate);

    // Create the transformgroup used for the billboard
    TransformGroup billBoardGroup = new TransformGroup();
    // Set the access rights to the group
    billBoardGroup.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
    // Add the cube to the group
    billBoardGroup.addChild(s3D1);

    Billboard myBillboard = new Billboard(billBoardGroup,

    Billboard.ROTATE_ABOUT_POINT, new Vector3f());

    myBillboard.setSchedulingBounds(billBoardGroup.getBounds());

    objScale.addChild(billBoardGroup);
    objScale.addChild(myBillboard);

    tgRotZ.addChild(objScale);
    tgRotY.addChild(tgRotZ);
    tgRotX.addChild(tgRotY);

    tg1.addChild(tgRotX);

    bg.addChild(tg1);

    return bg;

  }

  @SuppressWarnings("unused")
  private BranchGroup getBranchGroupRectangle(Parcelle p, boolean max) {
    IDirectPosition centre = p.getGeom().centroid();
    double taille = 50;
    IPolygon poly = this.traceRectangle(taille, centre);

    while (!p.getGeom().contains(poly)) {
      taille = taille / 2;
      poly = this.traceRectangle(taille, centre);
    }

    double CES = poly.area() / (p.getGeom().area());

    double nbEtage = 0;
    if (max) {
      nbEtage = this.getCosMax() / (CES);
    } else {
      nbEtage = this.getCosMin() / (CES);

    }

    GM_Solid sol = (GM_Solid) Extrusion2DObject.convertFromPolygon(poly, p
        .getGeom().coord().get(0).getZ(), p.getGeom().coord().get(0).getZ()
        + nbEtage * 3);
    ObjectCartoon obj = new ObjectCartoon();

    if (max) {
      return obj.processGeom(sol.getFacesList(), Color.red, Color.black, 3, 1);
    } else {
      return obj
          .processGeom(sol.getFacesList(), Color.green, Color.black, 3, 1);
    }

  }

  private IPolygon traceRectangle(double taille, IDirectPosition centre) {

    double x = centre.getX();
    double y = centre.getY();

    DirectPosition dp1 = new DirectPosition(x - taille, y - taille, 0);
    DirectPosition dp2 = new DirectPosition(x + taille, y - taille, 0);
    DirectPosition dp3 = new DirectPosition(x + taille, y + taille, 0);
    DirectPosition dp4 = new DirectPosition(x - taille, y + taille, 0);

    DirectPositionList dpl = new DirectPositionList();
    dpl.add(dp1);
    dpl.add(dp2);
    dpl.add(dp3);
    dpl.add(dp4);
    dpl.add(dp1);

    return new GM_Polygon(new GM_LineString(dpl));
  }

}
