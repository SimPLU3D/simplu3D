//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB)
// Reference Implementation, v2.1.3-b01-fcs
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source
// schema.
// Generated on: 2009.10.26 at 12:24:15 PM CET
//

package fr.ign.cogit.gru3d.regleUrba.reglesUrbanismes.regles;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;

import javax.media.j3d.Appearance;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Shape3D;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;

import com.sun.j3d.utils.geometry.GeometryInfo;

import fr.ign.cogit.geoxygene.api.spatial.coordgeom.IDirectPosition;
import fr.ign.cogit.geoxygene.api.spatial.coordgeom.IDirectPositionList;
import fr.ign.cogit.geoxygene.api.spatial.geomprim.IOrientableSurface;
import fr.ign.cogit.geoxygene.api.spatial.geomroot.IGeometry;
import fr.ign.cogit.geoxygene.sig3d.calculation.Proximity;
import fr.ign.cogit.geoxygene.sig3d.convert.java3d.ConversionJava3DGeOxygene;
import fr.ign.cogit.geoxygene.sig3d.geometry.Box3D;
import fr.ign.cogit.geoxygene.sig3d.sample.Symbology;
import fr.ign.cogit.geoxygene.spatial.coordgeom.GM_Polygon;
import fr.ign.cogit.geoxygene.spatial.geomprim.GM_Point;
import fr.ign.cogit.gru3d.regleUrba.Executor;
import fr.ign.cogit.gru3d.regleUrba.representation.ContrainteDistance;
import fr.ign.cogit.gru3d.regleUrba.representation.Incoherence;
import fr.ign.cogit.gru3d.regleUrba.schemageo.Batiment;
import fr.ign.cogit.gru3d.regleUrba.schemageo.Parcelle;
import fr.ign.cogit.gru3d.regleUrba.schemageo.Route;
import fr.ign.cogit.gru3d.regleUrba.schemageo.Toit;
import fr.ign.cogit.gru3d.regleUrba.util.Prospect;
import fr.ign.cogit.sig3d.analysis.ProspectCalculation;

/**
 * <p>
 * Java class for ReculRoute complex type.
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 * 
 * <pre>
 * &lt;complexType name="ReculRoute">
 *   &lt;complexContent>
 *     &lt;extension base="{}Recul">
 *       &lt;sequence>
 *         &lt;element name="distanceRecul" type="{}Distance"/>
 *       &lt;/sequence>
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "ReculRoute", propOrder = { "distanceRecul" })
public class ReculRoute extends Recul {

  @XmlElement(required = true)
  protected Distance distanceRecul;

  /**
   * Gets the value of the distanceRecul property.
   * 
   * @return possible object is {@link Distance }
   */
  @Override
  public Distance getDistanceRecul() {
    return this.distanceRecul;
  }

  /**
   * Sets the value of the distanceRecul property.
   * 
   * @param value allowed object is {@link Distance }
   */
  public void setDistanceRecul(Distance value) {
    this.distanceRecul = value;
  }

  public ReculRoute() {

  }

  public ReculRoute(Distance d) {
    this.distanceRecul = d;

  }

  @Override
  public String toString() {
    // TODO Auto-generated method stub
    return "Recul d'une distance de " + this.distanceRecul
        + " par rapport à la voirie bordant la parcelle";

  }

  @Override
  public List<Incoherence> isConsequenceChecked(Parcelle p, boolean represent) {

    System.out
        .println("Cette méthode ne devrait pas être exécutée : Classe ReculRoute");
    return new ArrayList<Incoherence>();
  }

  /**
   * Méthode particulière car en relation avec une route
   * 
   * @param p
   * @param route
   * @return
   */
  public List<Incoherence> isConsequenceChecked(Parcelle p, Route route, boolean represent) {

    List<Incoherence> lIncoherence = new ArrayList<Incoherence>();

    List<Batiment> lBati = p.getlBatimentsContenus();
    int nbBati = lBati.size();

    if (this.distanceRecul instanceof DistanceEuclidienne) {
      // Bati 3D, on regarde la distance entre la route et les toits des
      // batiments
      IGeometry geomRoute = route.getGeom();
      // On fabrique
      DistanceEuclidienne distEcul = (DistanceEuclidienne) this.distanceRecul;

      for (int i = 0; i < nbBati; i++) {
        Toit t = lBati.get(i).getToit();

        double distance = t.getGeom().distance(geomRoute);

        if (distance < distEcul.getDMin()) {

          if (Executor.VERBOSE) {
            System.out
                .println("Condition non vérifiée :  Distance minimale à une route non respectée");

          }
          
          
          if(represent){

          // BranchGroup bg = null;

          // bg = this.generateBranchGroup(t, route);

          Box3D b = new Box3D(t.getGeom());
          Box3D b2 = new Box3D(geomRoute);

          IDirectPosition dp1 = t.getGeom().centroid();
          IDirectPosition dp2 = geomRoute.centroid();

          dp1.setZ(b.getLLDP().getZ());
          dp2.setZ(b2.getLLDP().getZ());

          GM_Point ptIni;
          if (Double.isNaN(dp1.getX())) {
            ptIni = new GM_Point(b.getLLDP());
          } else {
            ptIni = new GM_Point(dp1);
          }

          GM_Point ptFin;

          if (Double.isNaN(dp2.getX())) {
            ptFin = new GM_Point(b2.getLLDP());
          } else {
            ptFin = new GM_Point(dp2);
          }

          BranchGroup bg = ContrainteDistance.generateBG(
              ptIni,
              ptFin,
              20,
              Color.red,
              10,
              2,
              5,
              Symbology.class.getResource(
                  "/demo3D/reglesurba/directionRoute.png").getPath());

          lIncoherence.add(new Incoherence(this, p, bg));
          
          }else{
            lIncoherence.add(null);
            return lIncoherence;
          }
        }

      }

    } else if (this.distanceRecul instanceof DistanceFHauteur) {

      DistanceFHauteur dH = (DistanceFHauteur) this.distanceRecul;
      IGeometry geomRoute = route.getGeom();

      double coeff = dH.getCoefficient();
      bouclebati: for (int i = 0; i < nbBati; i++) {
        // On prend la hauteur du batiment
        Batiment bati = lBati.get(i);

        Box3D bBati = new Box3D(bati.getGeom());
        double zmin = bBati.getLLDP().getZ();

        Toit t = bati.getToit();

        IDirectPositionList dpl = t.getGeom().coord();
        int nbPoints = dpl.size();

        for (int j = 0; j < nbPoints; j++) {
          // On regarde si chaque point des triangles respectent
          // H < d / coefficient
          IDirectPosition dp = dpl.get(j);

          double hauteur = dp.getZ() - zmin;

          GM_Point point = new GM_Point(dp);

          double distance = point.distance(geomRoute);

          if (hauteur > coeff * distance + dH.getHauteurOrigine()) { // + Double.parseDouble(p.getAttribute("Hauteur_Vo").toString()

            if (Executor.VERBOSE) {
              System.out
                  .println("Condition non vérifiée :  Distance fonction de hauteur à une route non respectée");

            }
            
            if(represent){

            BranchGroup bg = null;

            bg = this.generateBranchGroup(
                p,
                route,
                dp,
                dH.getCoefficient(),
                dH.getHauteurOrigine());

            lIncoherence.add(new Incoherence(this, p, bg));
            
            }else{
              lIncoherence.add(null);
              
            }
            
            continue bouclebati;
          }

        }

      }

    }

    if (Executor.VERBOSE) {
      if (lIncoherence.size() == 0) {
        System.out
            .println("Condition vérifiée :  Distance fonction de hauteur à une route respectée");
      }
    }
    return lIncoherence;

  }

  private BranchGroup generateBranchGroup(Toit t, Route r) {
    BranchGroup bg = new BranchGroup();
    Proximity c = new Proximity();
    c.nearest(t.getGeom().coord(), r.getGeom().coord());

    bg.addChild(new Shape3D(Prospect.genereLigne(c.nearest, c.nearest2, Color.red)));

    return bg;
  }

  private BranchGroup generateBranchGroup(Parcelle p, Route r,
      IDirectPosition dp, double pente, double hauteur) {

    BranchGroup bg = new BranchGroup();

    GM_Polygon polygone = (GM_Polygon)  ProspectCalculation.calculate(p.getGeom(),
        r.getGeom(), pente, hauteur);

    List<IOrientableSurface> lsurf = new ArrayList<IOrientableSurface>();
    lsurf.add(polygone);

    GeometryInfo geomInfo = ConversionJava3DGeOxygene
        .fromOrientableSToTriangleArray(lsurf);

    Appearance ap = Prospect.genereApparence(true, Color.red, 0.4, true);

    Shape3D shape = new Shape3D(geomInfo.getGeometryArray(), ap);
    BranchGroup bd = Prospect.generePoint(dp, ap);

    bg.addChild(shape);
    bg.addChild(bd);

    return bg;
  }

  private BranchGroup generateBranchGroup(Parcelle p, Route r,
      IDirectPosition dp, DistanceFHauteur d) {

    BranchGroup bg = new BranchGroup();

    GM_Polygon polygone = (GM_Polygon) Prospect.calculeEmprise(p.getGeom(),
        r.getGeom(), d);

    List<IOrientableSurface> lsurf = new ArrayList<IOrientableSurface>();
    lsurf.add(polygone);

    GeometryInfo geomInfo = ConversionJava3DGeOxygene
        .fromOrientableSToTriangleArray(lsurf);

    Appearance ap = Prospect.genereApparence(true, Color.red, 0.4, true);

    Shape3D shape = new Shape3D(geomInfo.getGeometryArray(), ap);
    BranchGroup bd = Prospect.generePoint(dp, ap);

    bg.addChild(shape);
    bg.addChild(bd);

    return bg;
  }

  public IGeometry genereContrainteEuclidienne(Parcelle p, Route r) {
    IGeometry geom = r.getGeom().buffer(
        ((DistanceEuclidienne) this.getDistanceRecul()).getDMin());
    return p.getGeom().difference(geom);
  }

}
